/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.2.0 (NJsonSchema v10.1.23.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import * as moment from 'moment';

export class OwnerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a document
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<Owner> {
        let url_ = this.baseUrl + "/v1/owners/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Owner> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Owner.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Owner>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: OwnerRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/owners/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/owners/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfOwner> {
        let url_ = this.baseUrl + "/v1/owners?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfOwner> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfOwner.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfOwner>(<any>null);
    }

    /**
     * Creates a document.
     * @param dto The dto.
     */
    post(dto: OwnerRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/owners";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class OwnerTypeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a document
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<OwnerType> {
        let url_ = this.baseUrl + "/v1/owner-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OwnerType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OwnerType.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OwnerType>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: OwnerTypeRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/owner-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/owner-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfOwnerType> {
        let url_ = this.baseUrl + "/v1/owner-types?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfOwnerType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfOwnerType.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfOwnerType>(<any>null);
    }

    /**
     * Creates a document.
     * @param dto The dto.
     */
    post(dto: OwnerTypeRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/owner-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class UnitClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a document
     */
    get(unitGroupId: string, id: string , cancelToken?: CancelToken | undefined): Promise<Unit> {
        let url_ = this.baseUrl + "/v1/unit-groups/{unitGroupId}/units/{id}";
        if (unitGroupId === undefined || unitGroupId === null)
            throw new Error("The parameter 'unitGroupId' must be defined.");
        url_ = url_.replace("{unitGroupId}", encodeURIComponent("" + unitGroupId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param request The request.
     */
    put(unitGroupId: string, id: string, request: UnitRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/unit-groups/{unitGroupId}/units/{id}";
        if (unitGroupId === undefined || unitGroupId === null)
            throw new Error("The parameter 'unitGroupId' must be defined.");
        url_ = url_.replace("{unitGroupId}", encodeURIComponent("" + unitGroupId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(unitGroupId: string, id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/unit-groups/{unitGroupId}/units/{id}";
        if (unitGroupId === undefined || unitGroupId === null)
            throw new Error("The parameter 'unitGroupId' must be defined.");
        url_ = url_.replace("{unitGroupId}", encodeURIComponent("" + unitGroupId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(unitGroupId: string, filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfUnit> {
        let url_ = this.baseUrl + "/v1/unit-groups/{unitGroupId}/units?";
        if (unitGroupId === undefined || unitGroupId === null)
            throw new Error("The parameter 'unitGroupId' must be defined.");
        url_ = url_.replace("{unitGroupId}", encodeURIComponent("" + unitGroupId));
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfUnit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfUnit.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfUnit>(<any>null);
    }

    /**
     * Creates a document.
     * @param request The request.
     */
    post(unitGroupId: string, request: UnitRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/unit-groups/{unitGroupId}/units";
        if (unitGroupId === undefined || unitGroupId === null)
            throw new Error("The parameter 'unitGroupId' must be defined.");
        url_ = url_.replace("{unitGroupId}", encodeURIComponent("" + unitGroupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Creates many units by range.
     * @param request The request.
     */
    post2(unitGroupId: string, request: UnitRangeRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/unit-groups/{unitGroupId}/units/range";
        if (unitGroupId === undefined || unitGroupId === null)
            throw new Error("The parameter 'unitGroupId' must be defined.");
        url_ = url_.replace("{unitGroupId}", encodeURIComponent("" + unitGroupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost2(_response);
        });
    }

    protected processPost2(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class UnitGroupClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a unit group.
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<UnitGroup> {
        let url_ = this.baseUrl + "/v1/unit-groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UnitGroup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UnitGroup.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UnitGroup>(<any>null);
    }

    /**
     * Updates a unit group by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: UnitGroupRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/unit-groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a unit group by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/unit-groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets unit groups by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfUnitGroup> {
        let url_ = this.baseUrl + "/v1/unit-groups?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfUnitGroup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfUnitGroup.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfUnitGroup>(<any>null);
    }

    /**
     * Creates a unit group.
     * @param dto The dto.
     */
    post(dto: UnitGroupRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/unit-groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class UnitTypeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a document
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<UnitType> {
        let url_ = this.baseUrl + "/v1/unit-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UnitType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UnitType.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UnitType>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: UnitTypeRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/unit-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/unit-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfUnitType> {
        let url_ = this.baseUrl + "/v1/unit-types?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfUnitType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfUnitType.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfUnitType>(<any>null);
    }

    /**
     * Creates a document.
     * @param dto The dto.
     */
    post(dto: UnitTypeRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/unit-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class MeetingSettingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets the current meeting settings
     */
    get(  cancelToken?: CancelToken | undefined): Promise<MeetingSettings> {
        let url_ = this.baseUrl + "/v1/settings/meetings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<MeetingSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MeetingSettings.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MeetingSettings>(<any>null);
    }

    /**
     * Updates the meeting settings
     */
    post(request: MeetingSettingsRequest , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/settings/meetings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class PersonClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a person.
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<Person> {
        let url_ = this.baseUrl + "/v1/people/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Person> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Person.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Person>(<any>null);
    }

    /**
     * Updates a person by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: PersonRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/people/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a person by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/people/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets people by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfPerson> {
        let url_ = this.baseUrl + "/v1/people?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfPerson> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfPerson.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfPerson>(<any>null);
    }

    /**
     * Creates a person.
     * @param dto The dto.
     */
    post(dto: PersonRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/people";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class PersonUnitClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a unit by person
     */
    get(personId: string, id: string , cancelToken?: CancelToken | undefined): Promise<Unit> {
        let url_ = this.baseUrl + "/v1/people/{personId}/units/{id}";
        if (personId === undefined || personId === null)
            throw new Error("The parameter 'personId' must be defined.");
        url_ = url_.replace("{personId}", encodeURIComponent("" + personId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Updates a owner by identifier.
     * @param id The id.
     * @param request The request.
     */
    put(personId: string, id: string, request: PersonUnitRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/people/{personId}/units/{id}";
        if (personId === undefined || personId === null)
            throw new Error("The parameter 'personId' must be defined.");
        url_ = url_.replace("{personId}", encodeURIComponent("" + personId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a owner by identifier.
     * @param id The id.
     */
    delete(personId: string, id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/people/{personId}/units/{id}";
        if (personId === undefined || personId === null)
            throw new Error("The parameter 'personId' must be defined.");
        url_ = url_.replace("{personId}", encodeURIComponent("" + personId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets units by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(personId: string, filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfUnit> {
        let url_ = this.baseUrl + "/v1/people/{personId}/units?";
        if (personId === undefined || personId === null)
            throw new Error("The parameter 'personId' must be defined.");
        url_ = url_.replace("{personId}", encodeURIComponent("" + personId));
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfUnit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfUnit.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfUnit>(<any>null);
    }

    /**
     * Creates a owner.
     * @param request The request.
     */
    post(personId: string, request: PersonUnitRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/people/{personId}/units";
        if (personId === undefined || personId === null)
            throw new Error("The parameter 'personId' must be defined.");
        url_ = url_.replace("{personId}", encodeURIComponent("" + personId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class DocumentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a document
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<Document> {
        let url_ = this.baseUrl + "/v1/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Document> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Document.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Document>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: DocumentRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfDocument> {
        let url_ = this.baseUrl + "/v1/documents?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfDocument> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfDocument.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfDocument>(<any>null);
    }

    /**
     * Creates a document.
     * @param dto The dto.
     */
    post(dto: DocumentRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/documents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class MeetingClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a meeting
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<Meeting> {
        let url_ = this.baseUrl + "/v1/meetings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Meeting> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Meeting.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Meeting>(<any>null);
    }

    /**
     * Updates a meeting by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: MeetingRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/meetings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a meeting by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/meetings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets mettings by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfMeeting> {
        let url_ = this.baseUrl + "/v1/meetings?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfMeeting> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfMeeting.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfMeeting>(<any>null);
    }

    /**
     * Creates a meeting.
     * @param dto The dto.
     */
    post(dto: MeetingRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/meetings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Invite.
     * @param id The id.
     */
    invite(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/meetings/{id}/invite";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInvite(_response);
        });
    }

    protected processInvite(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MeetingTypeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a meeting type.
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<MeetingType> {
        let url_ = this.baseUrl + "/v1/meeting-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<MeetingType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MeetingType.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MeetingType>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: MeetingTypeRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/meeting-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/meeting-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfMeetingType> {
        let url_ = this.baseUrl + "/v1/meeting-types?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfMeetingType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfMeetingType.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfMeetingType>(<any>null);
    }

    /**
     * Creates a document.
     * @param dto The dto.
     */
    post(dto: MeetingTypeRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/meeting-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class MeetingUnitClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a document
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<MeetingUnit> {
        let url_ = this.baseUrl + "/v1/meeting-units/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<MeetingUnit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MeetingUnit.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MeetingUnit>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: MeetingUnitRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/meeting-units/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/meeting-units/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfMeetingUnit> {
        let url_ = this.baseUrl + "/v1/meeting-units?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfMeetingUnit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfMeetingUnit.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfMeetingUnit>(<any>null);
    }

    /**
     * Creates a document.
     * @param dto The dto.
     */
    post(dto: MeetingUnitRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/meeting-units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class VotingSessionClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a document
     */
    get(meetingId: string, id: string , cancelToken?: CancelToken | undefined): Promise<VotingSession> {
        let url_ = this.baseUrl + "/v1/meetings/{meetingId}/voting-sessions/{id}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<VotingSession> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VotingSession.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VotingSession>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(meetingId: string, id: string, dto: VotingSessionRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/meetings/{meetingId}/voting-sessions/{id}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(meetingId: string, id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/meetings/{meetingId}/voting-sessions/{id}";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(meetingId: string, filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfVotingSession> {
        let url_ = this.baseUrl + "/v1/meetings/{meetingId}/voting-sessions?";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfVotingSession> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfVotingSession.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfVotingSession>(<any>null);
    }

    /**
     * Creates a document.
     * @param dto The dto.
     */
    post(meetingId: string, dto: VotingSessionRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/meetings/{meetingId}/voting-sessions";
        if (meetingId === undefined || meetingId === null)
            throw new Error("The parameter 'meetingId' must be defined.");
        url_ = url_.replace("{meetingId}", encodeURIComponent("" + meetingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class VotingTopicClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a document
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<VotingTopic> {
        let url_ = this.baseUrl + "/v1/voting-topics/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<VotingTopic> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VotingTopic.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VotingTopic>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: VotingTopicRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/voting-topics/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/voting-topics/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfVotingTopic> {
        let url_ = this.baseUrl + "/v1/voting-topics?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfVotingTopic> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfVotingTopic.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfVotingTopic>(<any>null);
    }

    /**
     * Creates a document.
     * @param dto The dto.
     */
    post(dto: VotingTopicRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/voting-topics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class VotingTopicOptionClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a document
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<VotingTopicOption> {
        let url_ = this.baseUrl + "/v1/voting-topic-options/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<VotingTopicOption> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VotingTopicOption.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VotingTopicOption>(<any>null);
    }

    /**
     * Updates a document by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: VotingTopicOptionRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/voting-topic-options/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a document by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/voting-topic-options/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets documents by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfVotingTopicOption> {
        let url_ = this.baseUrl + "/v1/voting-topic-options?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfVotingTopicOption> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfVotingTopicOption.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfVotingTopicOption>(<any>null);
    }

    /**
     * Creates a document.
     * @param dto The dto.
     */
    post(dto: VotingTopicOptionRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/voting-topic-options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class EmailTemplateClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a email template
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<EmailTemplate> {
        let url_ = this.baseUrl + "/v1/emails/templates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<EmailTemplate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EmailTemplate.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmailTemplate>(<any>null);
    }

    /**
     * Updates a email template by identifier.
     * @param id The id.
     * @param dto The dto.
     */
    put(id: string, dto: EmailTemplateRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/emails/templates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = resultData204 !== undefined ? resultData204 : <any>null;
            return result204;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * Deletes a email template by identifier.
     * @param id The id.
     */
    delete(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/emails/templates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets email templates by criteria.
     * @param filterBy The filter by.
     * @param orderBy The order by.
     * @param pageIndex (optional) The page index.
     * @param pageSize (optional) The page size.
     */
    getAll(filterBy: Filtering[] | null, orderBy: Sorting[] | null, pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedListResultOfEmailTemplate> {
        let url_ = this.baseUrl + "/v1/emails/templates?";
        if (filterBy === undefined)
            throw new Error("The parameter 'filterBy' must be defined.");
        else if(filterBy !== null)
            filterBy && filterBy.forEach((item, index) => {
                url_ += "filterBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (orderBy === undefined)
            throw new Error("The parameter 'orderBy' must be defined.");
        else if(orderBy !== null)
            orderBy && orderBy.forEach((item, index) => {
                url_ += "orderBy=" + encodeURIComponent(item.toString()) + "&";
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedListResultOfEmailTemplate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedListResultOfEmailTemplate.fromJS(resultData200);
            return result200;
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedListResultOfEmailTemplate>(<any>null);
    }

    /**
     * Creates a email template.
     * @param dto The dto.
     */
    post(dto: EmailTemplateRequest , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/v1/emails/templates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return result201;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = resultData409 !== undefined ? resultData409 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        this.extensions![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class Owner implements IOwner {
    id?: string;
    person?: Person | undefined;
    unit?: Unit | undefined;
    type?: OwnerType | undefined;

    constructor(data?: IOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>undefined;
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : <any>undefined;
            this.type = _data["type"] ? OwnerType.fromJS(_data["type"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Owner {
        data = typeof data === 'object' ? data : {};
        let result = new Owner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOwner {
    id?: string;
    person?: Person | undefined;
    unit?: Unit | undefined;
    type?: OwnerType | undefined;
}

export abstract class AuditMetadata implements IAuditMetadata {
    createdById?: string | undefined;
    createdOn?: moment.Moment;
    lastUpdatedById?: string | undefined;
    lastUpdatedOn?: moment.Moment | undefined;

    constructor(data?: IAuditMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdById = _data["createdById"];
            this.createdOn = _data["createdOn"] ? moment.parseZone(_data["createdOn"].toString()) : <any>undefined;
            this.lastUpdatedById = _data["lastUpdatedById"];
            this.lastUpdatedOn = _data["lastUpdatedOn"] ? moment.parseZone(_data["lastUpdatedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditMetadata {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditMetadata' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdById"] = this.createdById;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString(true) : <any>undefined;
        data["lastUpdatedById"] = this.lastUpdatedById;
        data["lastUpdatedOn"] = this.lastUpdatedOn ? this.lastUpdatedOn.toISOString(true) : <any>undefined;
        return data; 
    }
}

export interface IAuditMetadata {
    createdById?: string | undefined;
    createdOn?: moment.Moment;
    lastUpdatedById?: string | undefined;
    lastUpdatedOn?: moment.Moment | undefined;
}

export class Person extends AuditMetadata implements IPerson {
    id?: string;
    address?: Address | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    nickname?: string | undefined;
    taxNumber?: string | undefined;
    idNumber?: string | undefined;
    type?: PersonType;

    constructor(data?: IPerson) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.mobilePhoneNumber = _data["mobilePhoneNumber"];
            this.nickname = _data["nickname"];
            this.taxNumber = _data["taxNumber"];
            this.idNumber = _data["idNumber"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["nickname"] = this.nickname;
        data["taxNumber"] = this.taxNumber;
        data["idNumber"] = this.idNumber;
        data["type"] = this.type;
        super.toJSON(data);
        return data; 
    }
}

export interface IPerson extends IAuditMetadata {
    id?: string;
    address?: Address | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    nickname?: string | undefined;
    taxNumber?: string | undefined;
    idNumber?: string | undefined;
    type?: PersonType;
}

export class Address extends AuditMetadata implements IAddress {
    id?: string;
    address1?: string | undefined;
    address2?: string | undefined;
    number?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    postalCode?: string | undefined;

    constructor(data?: IAddress) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.number = _data["number"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["number"] = this.number;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IAddress extends IAuditMetadata {
    id?: string;
    address1?: string | undefined;
    address2?: string | undefined;
    number?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    postalCode?: string | undefined;
}

export enum PersonType {
    Fisical = 0,
    Legal = 1,
}

export class Unit implements IUnit {
    id?: string;
    floor?: number;
    floorType?: FloorType;
    block?: string | undefined;
    blockDescription?: string | undefined;
    side?: string | undefined;
    code?: string | undefined;
    codePrefix?: string | undefined;
    codeSuffix?: string | undefined;
    type?: UnitType | undefined;
    unitGroup?: UnitGroup | undefined;

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.floor = _data["floor"];
            this.floorType = _data["floorType"];
            this.block = _data["block"];
            this.blockDescription = _data["blockDescription"];
            this.side = _data["side"];
            this.code = _data["code"];
            this.codePrefix = _data["codePrefix"];
            this.codeSuffix = _data["codeSuffix"];
            this.type = _data["type"] ? UnitType.fromJS(_data["type"]) : <any>undefined;
            this.unitGroup = _data["unitGroup"] ? UnitGroup.fromJS(_data["unitGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["floor"] = this.floor;
        data["floorType"] = this.floorType;
        data["block"] = this.block;
        data["blockDescription"] = this.blockDescription;
        data["side"] = this.side;
        data["code"] = this.code;
        data["codePrefix"] = this.codePrefix;
        data["codeSuffix"] = this.codeSuffix;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["unitGroup"] = this.unitGroup ? this.unitGroup.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUnit {
    id?: string;
    floor?: number;
    floorType?: FloorType;
    block?: string | undefined;
    blockDescription?: string | undefined;
    side?: string | undefined;
    code?: string | undefined;
    codePrefix?: string | undefined;
    codeSuffix?: string | undefined;
    type?: UnitType | undefined;
    unitGroup?: UnitGroup | undefined;
}

export enum FloorType {
    Underground = 0,
    GroundFloor = 1,
    Floor = 2,
    Roof = 3,
}

export class UnitType implements IUnitType {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    createdOn?: moment.Moment;

    constructor(data?: IUnitType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdOn = _data["createdOn"] ? moment.parseZone(_data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UnitType {
        data = typeof data === 'object' ? data : {};
        let result = new UnitType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString(true) : <any>undefined;
        return data; 
    }
}

export interface IUnitType {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    createdOn?: moment.Moment;
}

export class UnitGroup implements IUnitGroup {
    id?: string;
    name?: string | undefined;
    createdOn?: moment.Moment;

    constructor(data?: IUnitGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.createdOn = _data["createdOn"] ? moment.parseZone(_data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UnitGroup {
        data = typeof data === 'object' ? data : {};
        let result = new UnitGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString(true) : <any>undefined;
        return data; 
    }
}

export interface IUnitGroup {
    id?: string;
    name?: string | undefined;
    createdOn?: moment.Moment;
}

export class OwnerType implements IOwnerType {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IOwnerType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): OwnerType {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IOwnerType {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
}

export class PagedListResultOfOwner implements IPagedListResultOfOwner {
    items?: Owner[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Owner.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfOwner {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfOwner {
    items?: Owner[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export abstract class Filtering implements IFiltering {
    columnName?: string | undefined;
    operator?: FilterOperator;
    stringValue?: string | undefined;

    constructor(data?: IFiltering) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    getOperatorName() : string {
            const op = this.operator || FilterOperator.Equal;
            switch(op)
            {
                case FilterOperator.Equal: return "eq";
                case FilterOperator.NotEqual: return "neq";
                case FilterOperator.Contains: return "contains";
                case FilterOperator.StartsWith: return "sw";
                case FilterOperator.EndsWith: return "ew";
                case FilterOperator.GreaterThan: return "gt";
                case FilterOperator.GreaterThanOrEqual: return "gte";
                case FilterOperator.LessThan: return "lt";
                case FilterOperator.LessThanOrEqual: return "lte";
            }
        }
    public toString = () : string => { return `${this.columnName}:${this.getOperatorName()}(${this.stringValue})`;}
    init(_data?: any) {
        if (_data) {
            this.columnName = _data["columnName"];
            this.operator = _data["operator"];
            this.stringValue = _data["stringValue"];
        }
    }

    static fromJS(data: any): Filtering {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Filtering' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnName"] = this.columnName;
        data["operator"] = this.operator;
        data["stringValue"] = this.stringValue;
        return data; 
    }
}

export interface IFiltering {
    columnName?: string | undefined;
    operator?: FilterOperator;
    stringValue?: string | undefined;
}

export enum FilterOperator {
    Equal = 0,
    NotEqual = 1,
    Contains = 2,
    StartsWith = 3,
    EndsWith = 4,
    GreaterThan = 5,
    GreaterThanOrEqual = 6,
    LessThan = 7,
    LessThanOrEqual = 8,
}

export abstract class Sorting implements ISorting {
    columnName?: string | undefined;
    sortDirection?: SortDirection;

    constructor(data?: ISorting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    
    public toString = () : string => { return `${this.columnName}:${this.sortDirection == SortDirection.Ascending ? "asc" : "desc"}`;}
    init(_data?: any) {
        if (_data) {
            this.columnName = _data["columnName"];
            this.sortDirection = _data["sortDirection"];
        }
    }

    static fromJS(data: any): Sorting {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Sorting' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnName"] = this.columnName;
        data["sortDirection"] = this.sortDirection;
        return data; 
    }
}

export interface ISorting {
    columnName?: string | undefined;
    sortDirection?: SortDirection;
}

export enum SortDirection {
    Ascending = 0,
    Descending = 1,
}

export class OwnerRequest implements IOwnerRequest {
    personId?: string;
    unitId?: string;
    ownerTypeId?: string;

    constructor(data?: IOwnerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personId = _data["personId"];
            this.unitId = _data["unitId"];
            this.ownerTypeId = _data["ownerTypeId"];
        }
    }

    static fromJS(data: any): OwnerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["unitId"] = this.unitId;
        data["ownerTypeId"] = this.ownerTypeId;
        return data; 
    }
}

export interface IOwnerRequest {
    personId?: string;
    unitId?: string;
    ownerTypeId?: string;
}

export class PagedListResultOfOwnerType implements IPagedListResultOfOwnerType {
    items?: OwnerType[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfOwnerType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OwnerType.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfOwnerType {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfOwnerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfOwnerType {
    items?: OwnerType[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class OwnerTypeRequest implements IOwnerTypeRequest {
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IOwnerTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): OwnerTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IOwnerTypeRequest {
    name?: string | undefined;
    description?: string | undefined;
}

export class PagedListResultOfUnit implements IPagedListResultOfUnit {
    items?: Unit[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Unit.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfUnit {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfUnit {
    items?: Unit[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class UnitRequest implements IUnitRequest {
    floor?: number;
    floorType?: FloorType;
    block?: string | undefined;
    blockDescription?: string | undefined;
    side?: string | undefined;
    code?: string | undefined;
    codePrefix?: string | undefined;
    codeSuffix?: string | undefined;
    unitTypeId?: string;

    constructor(data?: IUnitRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.floor = _data["floor"];
            this.floorType = _data["floorType"];
            this.block = _data["block"];
            this.blockDescription = _data["blockDescription"];
            this.side = _data["side"];
            this.code = _data["code"];
            this.codePrefix = _data["codePrefix"];
            this.codeSuffix = _data["codeSuffix"];
            this.unitTypeId = _data["unitTypeId"];
        }
    }

    static fromJS(data: any): UnitRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UnitRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floor"] = this.floor;
        data["floorType"] = this.floorType;
        data["block"] = this.block;
        data["blockDescription"] = this.blockDescription;
        data["side"] = this.side;
        data["code"] = this.code;
        data["codePrefix"] = this.codePrefix;
        data["codeSuffix"] = this.codeSuffix;
        data["unitTypeId"] = this.unitTypeId;
        return data; 
    }
}

export interface IUnitRequest {
    floor?: number;
    floorType?: FloorType;
    block?: string | undefined;
    blockDescription?: string | undefined;
    side?: string | undefined;
    code?: string | undefined;
    codePrefix?: string | undefined;
    codeSuffix?: string | undefined;
    unitTypeId?: string;
}

export class UnitRangeRequest implements IUnitRangeRequest {
    floor?: number;
    floorType?: FloorType;
    block?: string | undefined;
    blockDescription?: string | undefined;
    side?: string | undefined;
    codeStart?: number;
    codeEnd?: number;
    codePrefix?: string | undefined;
    codeSuffix?: string | undefined;
    unitTypeId?: string;

    constructor(data?: IUnitRangeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.floor = _data["floor"];
            this.floorType = _data["floorType"];
            this.block = _data["block"];
            this.blockDescription = _data["blockDescription"];
            this.side = _data["side"];
            this.codeStart = _data["codeStart"];
            this.codeEnd = _data["codeEnd"];
            this.codePrefix = _data["codePrefix"];
            this.codeSuffix = _data["codeSuffix"];
            this.unitTypeId = _data["unitTypeId"];
        }
    }

    static fromJS(data: any): UnitRangeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UnitRangeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floor"] = this.floor;
        data["floorType"] = this.floorType;
        data["block"] = this.block;
        data["blockDescription"] = this.blockDescription;
        data["side"] = this.side;
        data["codeStart"] = this.codeStart;
        data["codeEnd"] = this.codeEnd;
        data["codePrefix"] = this.codePrefix;
        data["codeSuffix"] = this.codeSuffix;
        data["unitTypeId"] = this.unitTypeId;
        return data; 
    }
}

export interface IUnitRangeRequest {
    floor?: number;
    floorType?: FloorType;
    block?: string | undefined;
    blockDescription?: string | undefined;
    side?: string | undefined;
    codeStart?: number;
    codeEnd?: number;
    codePrefix?: string | undefined;
    codeSuffix?: string | undefined;
    unitTypeId?: string;
}

export class PagedListResultOfUnitGroup implements IPagedListResultOfUnitGroup {
    items?: UnitGroup[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfUnitGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UnitGroup.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfUnitGroup {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfUnitGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfUnitGroup {
    items?: UnitGroup[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class UnitGroupRequest implements IUnitGroupRequest {
    name?: string | undefined;

    constructor(data?: IUnitGroupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UnitGroupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UnitGroupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IUnitGroupRequest {
    name?: string | undefined;
}

export class PagedListResultOfUnitType implements IPagedListResultOfUnitType {
    items?: UnitType[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfUnitType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UnitType.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfUnitType {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfUnitType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfUnitType {
    items?: UnitType[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class UnitTypeRequest implements IUnitTypeRequest {
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUnitTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UnitTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UnitTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUnitTypeRequest {
    name?: string | undefined;
    description?: string | undefined;
}

export class MeetingSettings implements IMeetingSettings {
    creationEmailTemplate?: EmailTemplate | undefined;
    beforeNotificationEmailTemplate?: EmailTemplate | undefined;

    constructor(data?: IMeetingSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationEmailTemplate = _data["creationEmailTemplate"] ? EmailTemplate.fromJS(_data["creationEmailTemplate"]) : <any>undefined;
            this.beforeNotificationEmailTemplate = _data["beforeNotificationEmailTemplate"] ? EmailTemplate.fromJS(_data["beforeNotificationEmailTemplate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MeetingSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationEmailTemplate"] = this.creationEmailTemplate ? this.creationEmailTemplate.toJSON() : <any>undefined;
        data["beforeNotificationEmailTemplate"] = this.beforeNotificationEmailTemplate ? this.beforeNotificationEmailTemplate.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMeetingSettings {
    creationEmailTemplate?: EmailTemplate | undefined;
    beforeNotificationEmailTemplate?: EmailTemplate | undefined;
}

export class EmailTemplate implements IEmailTemplate {
    id?: string;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IEmailTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): EmailTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export interface IEmailTemplate {
    id?: string;
    name?: string | undefined;
    code?: string | undefined;
}

export class MeetingSettingsRequest implements IMeetingSettingsRequest {
    creationEmailTemplateId?: string;
    beforeNotificationEmailTemplateId?: string;

    constructor(data?: IMeetingSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationEmailTemplateId = _data["creationEmailTemplateId"];
            this.beforeNotificationEmailTemplateId = _data["beforeNotificationEmailTemplateId"];
        }
    }

    static fromJS(data: any): MeetingSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationEmailTemplateId"] = this.creationEmailTemplateId;
        data["beforeNotificationEmailTemplateId"] = this.beforeNotificationEmailTemplateId;
        return data; 
    }
}

export interface IMeetingSettingsRequest {
    creationEmailTemplateId?: string;
    beforeNotificationEmailTemplateId?: string;
}

export class PagedListResultOfPerson implements IPagedListResultOfPerson {
    items?: Person[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Person.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfPerson {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfPerson {
    items?: Person[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class AddressRequest implements IAddressRequest {
    address1?: string | undefined;
    address2?: string | undefined;
    addressNumber?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    postalCode?: string | undefined;

    constructor(data?: IAddressRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.addressNumber = _data["addressNumber"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
        }
    }

    static fromJS(data: any): AddressRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddressRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["addressNumber"] = this.addressNumber;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        return data; 
    }
}

export interface IAddressRequest {
    address1?: string | undefined;
    address2?: string | undefined;
    addressNumber?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    postalCode?: string | undefined;
}

export class PersonRequest extends AddressRequest implements IPersonRequest {
    name?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    nickname?: string | undefined;
    taxNumber?: string | undefined;
    idNumber?: string | undefined;
    type?: PersonType;

    constructor(data?: IPersonRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.mobilePhoneNumber = _data["mobilePhoneNumber"];
            this.nickname = _data["nickname"];
            this.taxNumber = _data["taxNumber"];
            this.idNumber = _data["idNumber"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): PersonRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["nickname"] = this.nickname;
        data["taxNumber"] = this.taxNumber;
        data["idNumber"] = this.idNumber;
        data["type"] = this.type;
        super.toJSON(data);
        return data; 
    }
}

export interface IPersonRequest extends IAddressRequest {
    name?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    nickname?: string | undefined;
    taxNumber?: string | undefined;
    idNumber?: string | undefined;
    type?: PersonType;
}

export class PersonUnitRequest implements IPersonUnitRequest {
    unitId?: string;
    ownerTypeId?: string;

    constructor(data?: IPersonUnitRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unitId = _data["unitId"];
            this.ownerTypeId = _data["ownerTypeId"];
        }
    }

    static fromJS(data: any): PersonUnitRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PersonUnitRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        data["ownerTypeId"] = this.ownerTypeId;
        return data; 
    }
}

export interface IPersonUnitRequest {
    unitId?: string;
    ownerTypeId?: string;
}

export class Document implements IDocument {

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IDocument {
}

export class PagedListResultOfDocument implements IPagedListResultOfDocument {
    items?: Document[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Document.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfDocument {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfDocument {
    items?: Document[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class DocumentRequest implements IDocumentRequest {

    constructor(data?: IDocumentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DocumentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IDocumentRequest {
}

export class Meeting implements IMeeting {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    type?: MeetingType | undefined;
    startsOn?: moment.Moment | undefined;
    endsOn?: moment.Moment | undefined;
    statusCode?: MeetingStatus;

    constructor(data?: IMeeting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"] ? MeetingType.fromJS(_data["type"]) : <any>undefined;
            this.startsOn = _data["startsOn"] ? moment.parseZone(_data["startsOn"].toString()) : <any>undefined;
            this.endsOn = _data["endsOn"] ? moment.parseZone(_data["endsOn"].toString()) : <any>undefined;
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): Meeting {
        data = typeof data === 'object' ? data : {};
        let result = new Meeting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["startsOn"] = this.startsOn ? this.startsOn.toISOString(true) : <any>undefined;
        data["endsOn"] = this.endsOn ? this.endsOn.toISOString(true) : <any>undefined;
        data["statusCode"] = this.statusCode;
        return data; 
    }
}

export interface IMeeting {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    type?: MeetingType | undefined;
    startsOn?: moment.Moment | undefined;
    endsOn?: moment.Moment | undefined;
    statusCode?: MeetingStatus;
}

export class MeetingType extends AuditMetadata implements IMeetingType {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IMeetingType) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MeetingType {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        super.toJSON(data);
        return data; 
    }
}

export interface IMeetingType extends IAuditMetadata {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
}

export enum MeetingStatus {
    Created = 0,
}

export class PagedListResultOfMeeting implements IPagedListResultOfMeeting {
    items?: Meeting[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfMeeting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Meeting.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfMeeting {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfMeeting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfMeeting {
    items?: Meeting[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class MeetingRequest implements IMeetingRequest {
    name?: string | undefined;
    description?: string | undefined;
    meetingTypeId?: string;
    startsOn?: moment.Moment;
    endsOn?: moment.Moment;
    statusCode?: MeetingStatus;

    constructor(data?: IMeetingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.meetingTypeId = _data["meetingTypeId"];
            this.startsOn = _data["startsOn"] ? moment.parseZone(_data["startsOn"].toString()) : <any>undefined;
            this.endsOn = _data["endsOn"] ? moment.parseZone(_data["endsOn"].toString()) : <any>undefined;
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): MeetingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["meetingTypeId"] = this.meetingTypeId;
        data["startsOn"] = this.startsOn ? this.startsOn.toISOString(true) : <any>undefined;
        data["endsOn"] = this.endsOn ? this.endsOn.toISOString(true) : <any>undefined;
        data["statusCode"] = this.statusCode;
        return data; 
    }
}

export interface IMeetingRequest {
    name?: string | undefined;
    description?: string | undefined;
    meetingTypeId?: string;
    startsOn?: moment.Moment;
    endsOn?: moment.Moment;
    statusCode?: MeetingStatus;
}

export class PagedListResultOfMeetingType implements IPagedListResultOfMeetingType {
    items?: MeetingType[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfMeetingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MeetingType.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfMeetingType {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfMeetingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfMeetingType {
    items?: MeetingType[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class MeetingTypeRequest implements IMeetingTypeRequest {
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IMeetingTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MeetingTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IMeetingTypeRequest {
    name?: string | undefined;
    description?: string | undefined;
}

export class MeetingUnit implements IMeetingUnit {

    constructor(data?: IMeetingUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MeetingUnit {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IMeetingUnit {
}

export class PagedListResultOfMeetingUnit implements IPagedListResultOfMeetingUnit {
    items?: MeetingUnit[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfMeetingUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MeetingUnit.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfMeetingUnit {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfMeetingUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfMeetingUnit {
    items?: MeetingUnit[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class MeetingUnitRequest implements IMeetingUnitRequest {

    constructor(data?: IMeetingUnitRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MeetingUnitRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingUnitRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IMeetingUnitRequest {
}

export class VotingSession implements IVotingSession {
    id?: string;
    description?: string | undefined;
    order?: number;
    startsOn?: moment.Moment;
    endsOn?: moment.Moment;

    constructor(data?: IVotingSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.order = _data["order"];
            this.startsOn = _data["startsOn"] ? moment.parseZone(_data["startsOn"].toString()) : <any>undefined;
            this.endsOn = _data["endsOn"] ? moment.parseZone(_data["endsOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VotingSession {
        data = typeof data === 'object' ? data : {};
        let result = new VotingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["order"] = this.order;
        data["startsOn"] = this.startsOn ? this.startsOn.toISOString(true) : <any>undefined;
        data["endsOn"] = this.endsOn ? this.endsOn.toISOString(true) : <any>undefined;
        return data; 
    }
}

export interface IVotingSession {
    id?: string;
    description?: string | undefined;
    order?: number;
    startsOn?: moment.Moment;
    endsOn?: moment.Moment;
}

export class PagedListResultOfVotingSession implements IPagedListResultOfVotingSession {
    items?: VotingSession[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfVotingSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VotingSession.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfVotingSession {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfVotingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfVotingSession {
    items?: VotingSession[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class VotingSessionRequest implements IVotingSessionRequest {
    startsOn?: moment.Moment;
    endsOn?: moment.Moment;

    constructor(data?: IVotingSessionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startsOn = _data["startsOn"] ? moment.parseZone(_data["startsOn"].toString()) : <any>undefined;
            this.endsOn = _data["endsOn"] ? moment.parseZone(_data["endsOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VotingSessionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VotingSessionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startsOn"] = this.startsOn ? this.startsOn.toISOString(true) : <any>undefined;
        data["endsOn"] = this.endsOn ? this.endsOn.toISOString(true) : <any>undefined;
        return data; 
    }
}

export interface IVotingSessionRequest {
    startsOn?: moment.Moment;
    endsOn?: moment.Moment;
}

export class VotingTopic implements IVotingTopic {

    constructor(data?: IVotingTopic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): VotingTopic {
        data = typeof data === 'object' ? data : {};
        let result = new VotingTopic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IVotingTopic {
}

export class PagedListResultOfVotingTopic implements IPagedListResultOfVotingTopic {
    items?: VotingTopic[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfVotingTopic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VotingTopic.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfVotingTopic {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfVotingTopic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfVotingTopic {
    items?: VotingTopic[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class VotingTopicRequest implements IVotingTopicRequest {

    constructor(data?: IVotingTopicRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): VotingTopicRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VotingTopicRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IVotingTopicRequest {
}

export class VotingTopicOption implements IVotingTopicOption {

    constructor(data?: IVotingTopicOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): VotingTopicOption {
        data = typeof data === 'object' ? data : {};
        let result = new VotingTopicOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IVotingTopicOption {
}

export class PagedListResultOfVotingTopicOption implements IPagedListResultOfVotingTopicOption {
    items?: VotingTopicOption[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfVotingTopicOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VotingTopicOption.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfVotingTopicOption {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfVotingTopicOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfVotingTopicOption {
    items?: VotingTopicOption[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class VotingTopicOptionRequest implements IVotingTopicOptionRequest {

    constructor(data?: IVotingTopicOptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): VotingTopicOptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VotingTopicOptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IVotingTopicOptionRequest {
}

export class PagedListResultOfEmailTemplate implements IPagedListResultOfEmailTemplate {
    items?: EmailTemplate[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;

    constructor(data?: IPagedListResultOfEmailTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmailTemplate.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedListResultOfEmailTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListResultOfEmailTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IPagedListResultOfEmailTemplate {
    items?: EmailTemplate[] | undefined;
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
}

export class EmailTemplateRequest implements IEmailTemplateRequest {
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IEmailTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): EmailTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export interface IEmailTemplateRequest {
    name?: string | undefined;
    code?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}